# 模块

JS的主要运行环境是浏览器，最初不支持`模块`，后续在ES6中添加了模块功能。

## ES6之前的模块实现

在标准化之前，存在多种第三方模块实现方案，但他们已经成为历史，因此这里省略。

## ES6模块

### HTML中的模块

浏览器中的JS代码都是在HTML页面中声明的，现在可以声明为模块：

```html
<!--可以是内嵌代码，或者外部文件-->
<script type="module"></script>
```

这**区别于浏览器执行脚本的过程**。浏览器在解析HTML时遇到JS脚本会**同步**下载、解析、运行，而遇到JS模块会异步下载、解析，并在解析完HTML文档后按照先后顺序依次执行。

>注意，`async`是脚本执行模式的属性，表示异步执行。而JS模块已经是异步执行了，因此不需要这个属性。

两种执行模式，除了下载、解析、运行顺序不同外，还在语言层面存在不同：

- 模块的顶级this为undefiend
- 模块不共享命名空间

### Node.js中的模块

Node.js环境也支持ES6模块标准：

- 一个模块项目对外界而言是一个模块
- 项目中每个独立的`.js`文件是项目的子模块

## 基本语法

JS的模块系统是对脚本时代JS的使用习惯的概括和扩展。相比于其它编程语言，JS的模块系统很简单，但又存在着JS特有的不同。

### 模块

模块是JS代码组织的基本单元，一个模块就是一个`.js`文件，无论是在浏览器中还是在Node.js中都是如此。

>脚本时代的JS，一个库就是一个文件。
>
>作为对比，一些编程语言会有基于文件夹的`包`抽象（Java,Go）这与它们的核心目标平台是操作系统有关。

### 命名导出

模块显式声明它对外暴露的组件：

```js
const foo = 'foo';
export { foo };
//行内导出
export const foo = 'foo';
//别名
export { foo as myFoo };
```

以上导出模式被命名为`命名导出`，它主要是为了区分后续介绍的`默认导出`，除此外没什么深意。

使用如下方式导入`命名导出`：

```js
import { foo,myFoo } from './foo.js';
// 命名空间导出
import * as Foo from './foo.js';
console.log(Foo.foo);
```

### 默认导出（不建议使用）

脚本时代，库通过暴露一个全局变量来提供服务，默认导出功能就是用来承接这种模式。

```js
// 两者等价
// export default foo;
// export { foo as default };

// 行内默认导出
// export const foo = 'foo';

// 提供命名空间
export default {foo as myFoo};
```

一个模块只能有一个默认导出。

使用如下方式导入默认导出：

```js
import { default as foo } from './foo.js';
import foo from './foo.js';
```

### 默认导出的应用场景

默认导出是JS相比其它语言独有的语法，实际上大多数情况下与命名导出功能重合了，给JS使用者带来混乱。目前工程界不建议使用命名导出。

目前了解到使用默认导出的场景包括（也可以使用命名导出提到）：

- 使用JS/TS作为配置文件
- vue2（已过时）的组件写法
### 重导出

一些场景，我们需要在本模块暴露别的模块的导出内容：

```js
export * from './foo.js';
```
## 参考资料

《JavaScript高级程序设计》v4 26. 模块

[模块的困惑之处：默认导出和命名导出](https://archives.ecma-international.org/2014/misc/2014misc6.html)
