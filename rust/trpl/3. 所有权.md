# 所有权

`所有权`是Rust为了管理**堆内存**而定义的一个概念：

- Rust中的每个值都有一个变量，称为其`所有者`
- 只能存在一个所有者
- 当离开所有者作用域，该值将被删除

## 复习：栈与堆的区别导致的复杂性

*这部分属于计算机底层原理，这里只是简单的复习一下，如果不太明白，请参阅更系统的资料。*

计算机执行程序时，将内存区分为堆、栈，这早于操作系统、进程、线程等概念诞生，而这些高级概念也没有颠覆掉程序的基础执行模型，因此我们现在只关注最基础的程序执行模型。

在基础执行模型下，程序是一个顺序执行流，栈用于记录程序当前执行环境（通常在程序中为`函数`）的上下文信息（参数、局部变量），进入函数时创建栈帧，退出函数时摧毁栈帧。

堆是一块可以随机地址访问的内存，为了更好的管理堆，有专门的堆管理模块（对于运行在操作系统上的程序，这个模块由操作系统实现），程序调用API来申请堆上的内存、以及释放不再使用的内存。

堆内存的管理给程序带来了复杂性，比如忘记释放不再使用的内存导致内存泄露，访问已经释放的内容导致BUG，释放已经被释放的内存导致BUG...

不同的编程语言都试图为管理堆内存提供解决方案，Rust提出了`所有权`概念。

## 通过String来理解所有权

Rust中的`String`类型是可变长度字符串的封装。

**栈和堆同时分配**：`String`变量的底层实现可以分两部分，记录状态的值（包括指向堆上字符串内容的指针）是在栈上分配的，但存储字符串内容的空间是在堆上分配的。

**复制就是move（浅拷贝）**：复制String变量，只复制栈上的值，等同于`浅拷贝`，会导致所有权转移（原变量失效）。

所有权转移确保对堆上数据的引用始终只存在一个，这保证了回收内存的安全，同时简化了底层实现。

### 使用clone方法进行深拷贝

`clone`是一个惯用方法名，表示深拷贝。

```rust
let s1 = String::from("hello");
let s2 = s1.clone();
```

### 对纯栈上数据复制不会导致所有权的转移

纯栈上数据复制不会导致所有权的转移：

```rust
let s: &str = "hello";
let s2 = s;
println!("{},{}", s, s2)
```

### Copy trait与Drop trait

*trait：翻译为特质、特征、特点*

两者只能唯一存在，前者意味着是纯栈上数据类型，后者会在堆上分配内存，会执行所有权转移、在堆上分配和释放内存。

默认情况下，`标量类型`、只包含COPY trait的元素的`tupe`具有COPY trait。

### 函数调用

未实现Copy trait的类型的值，作为函数参数传递会带来所有权的转移，作为值返回也会导致所有权转移。

## 引用

引用不会造成所有权的转移，**引用默认无法修改其内容**。

引用最简单的用处就是避免调用函数时，值的所有权传递给函数再由返回值返回这样的样板且繁琐的操作。

Rust用`借用`术语表示`创建引用`这一行为，使用`借用的`修饰引用变量。

### 可变引用

可以将引用声明为`mut`来使得引用可以修改其值。

可变引用的作用范围无法重叠，也无法与不可变引用进行重叠，这种限制是为了编译时就避免`数据竞争`。

换句话说就是`在任何时候，你可以拥有一个可变引用或任意数量不变引用`。

## 切片

切片是对集合类型的（不可变）部分引用，Rust对其提供了语法支持。

### 字符串切片

`字符串切片`的类型是`&str`：

```rust
let s: String = String::from("hello world");
let hello: &str = &s[0..5];//从字符串创建引用
let hello: &str = "hello";//从字符串字面量创建引用
```

字符串字面量的实际类型就是`字符串切片`。

存在一个“技巧”，参数类型`&str`可以接收`&String`类型作为参数，这是通过`Deref`实现的（后续了解）。

### 数组切片

```rust
let data = [1, 2, 3, 4];
let slice: &[i32] = &data[0..2];
```