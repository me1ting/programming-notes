# 所有权

`所有权`是Rust为了管理**堆内存**而定义的一个概念：

- Rust中的每个值都有一个变量，称为其`所有者`
- 只能存在一个所有者
- 当离开所有者作用域，该值将被删除

## 复习：栈与堆的区别导致的复杂性

*这部分属于计算机底层原理，这里只是简单的复习一下，如果不太明白，请参阅更系统的资料。*

计算机执行程序时，主要将内存区分为堆、栈，这早于操作系统、进程、线程等概念诞生，而后续这些高级概念也没有颠覆掉程序的基础执行模型，因此我们现在只关注最基础的程序执行模型。

在基础执行模型下，程序是一个顺序执行流，栈用于记录程序当前执行环境（通常为`函数`）的上下文信息（参数、局部变量），进入函数时创建栈帧，退出函数时摧毁栈帧。

堆是一块可以随机地址访问的内存，为了更好的管理堆，有专门的堆管理模块，程序调用API来申请堆上的内存、以及释放不再使用的内存。

堆内存的管理给程序带来了复杂性，比如忘记释放不再使用的内存导致内存泄露，访问已经释放的内容导致错误...

不同的编程语言都试图为管理堆内存提供解决方案，Rust提出了`所有权`概念。

## 通过String来理解所有权

Rust中的`String`类型表示可变长度字符串。

**栈和堆同时分配**：`String`变量的底层实现可以分两部分，记录状态的值（包括指向堆上字符串内容的指针）是在栈上分配的，但存储字符串内容的空间是在堆上分配的。
### move

```rust
let s1 = String::from("hello");
let s2 = s1;
```

上面执行了复制操作，但因为String类型在栈和堆上同时分配，因此只复制了栈上数据。

此时，变量s1失效，Rust将这样的操作称为`移动`，称该值的所有权被转移。

所有权转移确保对堆上数据的引用始终只存在一个，这保证了回收内存的安全，同时简化了底层实现。

### clone

`clone`是一个惯用方法名，表示克隆一个对象。

```rust
let s1 = String::from("hello");
let s2 = s1.clone();
```

克隆对象会同时复制栈上数据和堆上数据。

### copy

纯栈上数据复制不会导致所有权的转移：

```rust
let s: &str = "hello";
let s2 = s;
println!("{},{}", s, s2);
```

### Copy trait与Drop trait

Rust通过`Copy`和`Drop`来表明一个类型是纯栈上数据类型，还是包括堆数据。

两者只能唯一存在，前者意味着是纯栈上数据类型，后者会执行所有权转移、在堆上分配和释放内存。

默认情况下，`标量类型`、只包含Copy trait的元素的`tupe`具有Copy trait。

### 函数调用

未实现Copy trait的类型的值，作为函数参数传递会带来所有权的转移，作为值返回也会导致所有权转移。

## 引用

引用不会造成所有权的转移，**引用默认无法修改其内容**。

引用最常见的用处就是避免调用函数时，值的所有权传递给函数再由返回值返回这样的样板操作。

Rust用`借用`术语表示`创建并使用引用`的行为，使用`借用的`修饰引用变量。

### 可变引用

可以创建`可变引用`，使得可以通过引用修改值：

```rust
fn main() {
    let mut a = 0;
    let b = &mut a;// 创建可变引用
    *b = 1;
    println!("{}", a); // 1
}
```

可变引用的作用范围无法重叠，也无法与不可变引用进行重叠，这种限制使得编译时就避免`数据竞争`。

换句话说就是`在任何时候，你可以拥有一个可变引用或任意数量不变引用`。

## 切片

切片是对集合类型的（不可变）部分引用，Rust对其提供了语法支持。

### 字符串切片

`字符串切片`是`str`类型的引用：

```rust
let s: String = String::from("hello world");
let hello: &str = &s[0..5];//从字符串创建引用
let hello: &str = "hello";//从字符串字面量创建引用
```

字符串字面量的实际类型就是`字符串切片`。

参数类型`&str`可以接收`&String`类型作为参数，这是通过`Deref`实现的（后续了解）。

```rust
fn print(&str s){
	print!(s)
}

fn test(){
	let hello = String::from("hello world");
	print(&hello);
}
```
### 数组切片

```rust
let data = [1, 2, 3, 4];
let slice: &[i32] = &data[0..2];
```