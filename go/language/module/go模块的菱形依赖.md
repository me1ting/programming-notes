# go模块的菱形依赖

## 什么是菱形依赖？

在所有支持依赖的编程语言中都会遇到如下问题：

![](_images/Pasted%20image%2020231128115810.png)

应用的两个第三方依赖都依赖同一个模块的不同版本，构建应用时如何选择该模块的版本？

不同的语言有不同的解决方案，而Go目前的模块系统理论上解决了这个问题，但实际使用依然面临这个问题。

## Go的解决方案

正如我们在 `2. 使用模块` 一文中所讲，Go的模块系统的理论基础是[语义化版本](https://semver.org/lang/zh-CN/)：

- MAJOR版本表示**不兼容**更新
- MINOR版本表示**向下兼容**的新增功能更新
- PATCH版本表示**向下兼容**的修复问题更新

Go的模块系统基于其兼容性原则，规定：

- 每个MAJOR版本在依赖树中只能存在一个实例
- 使用`MVS`计算特定MAJOR版本在依赖树中的实例版本

## 问题所在

![](_images/Pasted%20image%2020231128141111.png)

由于能力、问题复杂度等原因，很多模块的开发者都没法满足以上兼容性要求，因此很多库都停留在`0.y.z`的开发阶段版本，而迟迟不肯将MAJOR版本号升级到`1`，根据语义化版本规范说明，开发阶段版本不需要遵守兼容性要求。

即使是选择升级到`1.y.z`之上版本号的模块，也不能保证完全满足以上兼容性要求。

这使得Go当前的模块系统在实际应用中可能会出现兼容性问题：计算出的MVS版本可能与依赖该模块的某个模块存在兼容问题。

比如上图，计算出的`P3 V1.2.0`可能与`P1 V1.1.0`存在兼容性冲突。

## 解决办法

### 理论最佳办法

Go模块系统在未来更新：允许某个模块的MAJOR版本在依赖树中存在多个实例。

这也是很多编程语言的依赖管理方式，比如Java,Rust,Node.js等。

### 现实办法

以上图为例，我们可以：

- fork `P1 V1.1.0` ，然后使用internal`P3 V1.1.0`，注意更换掉P3的`模块路径`，这是最可行的办法
- fork P1 `V1.1.0`，升级依赖P3到`V1.1.0`，修复不兼容BUG

注意，经过测试，[replace](https://go.dev/ref/mod#go-mod-file-replace)指令并不能解决该问题。比如：

- fork P1，然后在P1的`go mod`中，使用并将`P3 V1.2.0`替换为`P3 V1.1.0`
- fork P1，然后在P1的`go mod`中，将`P3 V1.1.0`替换为internal`P3 V1.1.0`

## 参考资料

[blog: 为什么有了Go module后“依赖地狱”问题依然存在](https://tonybai.com/2022/03/12/dependency-hell-in-go/)
