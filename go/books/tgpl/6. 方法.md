# 方法

## Go的OOP理念

Go认为：

```
对象就是简单的值或者一个变量，拥有方法，方法是关联特定类型的函数。
```

_相比C++,Java等传统主流语言，Go与Rust采用了更加轻量、简单的对象模型。_

## 方法声明

Go采取`接收者`风格，这源于OOP的早期实现。接收者如同形式参数，不需要特殊的额外语法。了解一些概念：

- 方法名称和结构体字段共享同一命名空间（IDE会自动提醒，了解这回事即可）
- 方法可以绑定到任何命名且具体的类型之上（非接口类型与非指针类型）
- 方法不可以绑定指针类型，但接受者可以是类型的指针

```go
type Point struct {
	X, Y int
}

type PointPointer *Point

func (p PointPointer) TypeName() string {//绑定指针类型，编译错误
	return "Point"
}

func (*Point) TypeName2() string {//匿名接收者
	return "Point"
}
```

### 匿名接收者

正如上面的示例代码，方法接收者可以是匿名，表示不依赖于具体的对象。

## 指针接收者

根据Go的传参语法，所有参数都是通过复制的方式传递的，接受者也不例外。

因此只有当接收者为指针时才能访问原始对象。

Go做了语法优化，在调用方法时会在指针和对象之间进行自动切换，而不需要显式转换：

```go
(*p).doSomething()
(&obj).doSomething()
```

## 结构体内嵌/匿名字段对方法的影响

匿名字段可以是指针或具体类型，从语法上来讲会接收被嵌入的结构体的所有字段和方法。

**从本质上来讲，Go的结构体内嵌是一种组合而非继承**，只是吸收了继承的一些语法，如“接收”字段和方法。

方法按照直接声明、接收、间接接收的顺序按照层次进行查找，Go只要求同级不能出现重复的方法。

## 方法变量和表达式

使用一个变量来接收`方法表达式`，称为`方法变量`。

```go
distanceFromP := p.Distance
```

方法表达式是**和对象绑定**的，用在需要函数值的地方。

## 封装

Go采用基于命名的可访问性，Go目前仅支持包级别的可访问性控制。
