# 星团珠宝的node计算

通过预处理JSON为XML，能提升pob-headless的性能。但是一个难点在于星团珠宝的node需要手动计算，这是一个很复杂的实现。

## 记录JSON的变化

对于游侠右边的一个星团珠宝：

![](_images/Pasted%20image%2020240121194208.png)

通过记录游戏中点亮星团珠宝特定Node的前后JSON数据，发现`passiveSkills.json`记录了被点亮的Node：

```
"hashes_ex": [
    165,
    167
],
```

## 记录XML的变化

通过对比点亮节点前后的xml数据，我们得到了被点亮节点在XML中的表示：

```xml
<Spec ... node="..., 65824, 65826">
```

## 查看pob的实现

我们可以追踪`loadBuildFromJSON()`函数：

```
loadBuildFromJSON()
  build.importTab:ImportPassiveTreeAndJewels()
    self:ImportItem()
      self.build.itemsTab.slots[slotName]:SetSelItemId()
        self.itemsTab.build.spec:BuildClusterJewelGraphs()
          self:BuildSubgraph()
```

在debug中，发现`self.build.spec.allocSubgraphNodes`记录`65824, 65826`两个数字，因此使用断点判断在哪里插入这两个数字。

这段代码插入了这两个数字：

```lua
	-- Add synthetic nodes to the main node list
	for _, node in ipairs(subGraph.nodes) do
		self.nodes[node.id] = node
		if addToAllocatedSubgraphNodes(node) then
			t_insert(self.allocSubgraphNodes, node.id) -- 这里执行了插入
		end
		if node.type == "Socket" then
			-- Recurse to smaller jewels
			local jewel = self:GetJewel(self.jewels[node.id])
			if jewel and jewel.jewelData.clusterJewelValid then
				self:BuildSubgraph(jewel, node, id, upSize, importedNodes, importedGroups)
			end
		end
	end
```

通过调试这段代码，大致可以归纳：

- `subGraph`是pob中的星团对象，它使用到了`65824`,`65826`
- 通过对比`orbitIndex`字段，实现`65824`到`165`之间的映射
- 通过`hashes_ex`检查是否需要添加到`allocSubgraphNodes`

