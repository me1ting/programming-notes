# 基本概念

脚本的本质是`命令的集合`。linux提供了`shebang line`的特性，可以使用指定解释器执行脚本：

```
./script-file-name
```

新手在执行shell脚本时常遇到以下两个错误：

当前路径`.`不属于PATH，因此系统无法查找该脚本。

```
> demo.sh # 应该使用./demo.sh
> command not found
```

文件默认权限不包括可执行，需要赋予可执行权限。

```
> ./demo.sh # 应该chmod
> Permission denied
```

## 变量

这里的变量就是前面所讲的环境变量：

```
name=bash # 严格要求不允许空格
```

引用变量的值：

```
echo $name
echo ${name}
```

bash只支持文本数据，缺乏对不同数据类型的原生支持。

## 命令替换

把任意命令看作一个函数，命令替换就是“函数调用”，并返回值：

```
curr=$(date)
curr=`date`
```

## 退出状态码

在shell中每条命令都会返回退出状态码，范围（0~255），0表示成功，正数表示失败。自定义返回状态码：

```
exit 0
```

## 标准重定向

常用的主要有`>`,`>>`（追加）,`<`，三种重定向方式。

## 管道

不同于输入输出重定向，管道的目的是将一个命令的输出作为另一个命令的输入，而重定向的目的是将数据存储或读取已存储数据。

# 控制语句

bash支持编程语言中的if,switch,for语句，在语法细节上存在一些差异。

## 真值

bash中没有布尔类型，命令的执行成功（退出状态码为0）表示条件为真。

当需要进行逻辑判定时，需要使用`test`命令，其支持对数值、字符串、文件进行比较，基本能满足实际需求。bash-shell支持对其进行简写，并支持布尔操作：

```
[ condition1 ] && [ condition2 ] # 注意空格
[ condition1 ] || [ condition2 ]
```

# 输入

## 命令行参数

采用`位置参数`，并使用了特殊的语法。

## 交互输入、读取文件

使用`read`命令。

# 高级重定向

linux文件api采用`文件描述符`的概念，其中0,1,2为默认的输入、输出、错误输出，共9个。

bash可以控制进程的文件描述符，支持：

1. 基本输入输出重定向：

```
ls > out.txt
ls >> out.txt
cat < out.txt
```

2. 重定向文件描述符到文件：

```
ls 1>out.txt 2>err.txt
ls &>all.txt # &表示文件描述符1,2
cat 0< out.txt
```

3.重定向文件描述符到文件描述符：

```
ls 1>&2
```

重定向的影响范围可以是单行命令，也可以是对当前shell一直有效（需要使用exec命令）。

```
exec 3>&1
```

重定向到文件描述符类似指针，可以用来保存原始文件描述符：

```
exec 3>&1 #创建文件描述符3，保存文件描述符1原始指向
exec 1>out #重定向文件描述符1
执行若干命令
exec 1>&3 #恢复文件描述符1指向
```

重定向到黑洞文件`/dev/null`来接收不需要的数据。

可以使用临时文件，其基本原理是位于/tmp目录下的文件，每次重启会自动删除。

`tee`命令可以实现日志和显示器的同时输出。

# bash和信号

信号是Linux控制进程运行状态的接口。可以使用组合键模拟信号，也可以使用kill命令发送信号。

使用`nohup command&`将命令后台执行，其原理是：

- 后台模式`&`不占用终端输入，但依然会显示STDOUT,STDERR信息。
- shell退出会收到`SIGNHUP`信号，并传播给所有其子进程。通过nohup执行命令，将忽略该信号，这样即使终端退出，命令依然执行。nohup会忽略终端输入，并重定向STDOUT,STDERR。

# 函数和库

在bash中，函数本质是小型脚本，它有使用相同的参数语法、允许退出状态码、允许返回值。

一个脚本文件就是一个脚本库，修改脚本后，可以使用`source`工具重新导入该脚本。
