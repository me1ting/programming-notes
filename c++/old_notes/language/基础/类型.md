# 基本类型

沿用C的基本类型，与其它编译型语言也没有太大区别。

## 字面值

沿用C的字面值风格，并增加了许多前缀、后缀语法。

## 字符类型和字符串

只建议使用`char`类型，其它字符类型了解即可，使用场景很小。

### 字符串字面量

使用C风格：字符类型的数组指针，以'\0'结尾。

> 默认对于非ASCII使用本地编码，如中文Windows为GBK，中文Linux为UTF-8

支持其它编码的字符串字面量，如UTF-8：

```cpp
char[] str = u8"你好";//UTF-8编码单元为byte，C++中使用char表示
```

> [gstyleguide](https://google.github.io/styleguide/cppguide.html#Non-ASCII_Characters)
> 避免非ASCII字符，必要时只能使用UTF-8编码。除非必要，不使用其它编码。

> 对于C/C++核心来讲，由于std::string的缺陷，把字符串当二进制数据看待即可，字符串的高级处理应依赖于其它类库来实现。

# 变量

## 初始化（强调初始化与赋值的不同）

从底层来讲初始化和赋值确实不同，通常编程语言语法上会淡化区别，但唯独C++特别强调这种不同，并玩出了花样。

### 列表初始化

C++风格初始化语法：统一C++中变量的初始化方式，提供相比C风格更加安全初始化方式。

### 默认初始化

基本类型沿用C风格：全局变量**默认初始化**为0值，局部变量初始值未定义。
类：允许类自定义其初始化方式。

## 区分声明和定义

沿用C风格：对于外部文件定义的变量使用`extern`来表示其在外部文件中定义。

记住一点：**将其作为C/C++的一种基本的导入、导出机制**。

# 复合类型

## （左值）引用

一种**封装的更加安全的指针**：

创建：

```cpp
int ival = 1024;
int &refVal = ival;
int &r = ival,r = ival;//反逻辑但又符合C++逻辑的引用/指针与变量同时定义
```

沿用了C容易让人产生歧义的语法风格，别扭的理解为：`&`表示refVal是一个引用，指向`int`类型，`=`指向`ival`，对比Rust：

```
let i: i32 = 1;
let val_ref: &i32 = &i;//变量val_ref是一个i32的引用，其值为i的引用。
```

### 左值引用

C++的引用除了语法风格，最基本的也与Rust不同：

```cpp
int main() {
    int i = 1;
    int &j = i;
    j = 2;//直接作为左值使用
    std::cout << i <<std::endl;//2
}
```

```rust
fn main() {
    let mut i: i32 = 1;
    let j = &mut i;
    *j = 2;//必须解引用
    println!("{}",i)
}
```

可以作为左值使用，等价于被引用的变量，因此C++称这种引用为`左值引用`。

> Rust中的引用介于C++的左值引用和原始指针：不能作为左值，但又没那么原始。

## （原始）指针

C风格指针称为原始指针：指针是对象，存储的是地址。

```cpp
int ival = 42;
int *p = &ival;//需要取地址操作
```

空指针的规范字面量是`nullptr`。

### 指针的比较

两个相同类型的合法指针，可以使用`==`,`!=`比较它们所指向的对象。

### void\* 指针

源自C：指向任意类型对象的指针。某些语言存在这样的需求，如Java中的`Object`，Golang中的`interface {}`。

## 复合类型的声明

沿用C风格：语法设计的缺陷，导致别扭的写法：

```cpp
int* p1,r1;//将修饰符与类型写在一起，后面的语言都采用这种方式，但是C/C++中r1是int类型
int *p1,p2;//将修饰符与指针名写在一起
```

> [Google C++ Style Guide](https://google.github.io/styleguide/cppguide.html#Pointer_and_Reference_Expressions)要求：两者都可以，但不允许在多重声明中使用`*`,`&`

### 特例：指向指针的引用

```cpp
int i = 0;
int* p = &i;
int* &p = p;//指向指针的引用
```

不用记住，需要时查阅即可。

> 理解多个修饰符的基本技巧是就近原则，理解不了也没有关系，借助搜索引擎、书籍并记录即可。

# 类型工具

一些操作类型的工具。

## 类型定义

使用`typedef`可以创建类型的别名，或者说定义依赖于底层类型的类型，主要用于简化“复杂组合类型”（个人定义，指使用\*,&,const...构建的复杂类型标志）。

### using 别名

类似其它语言引入风格的别名：

```cpp
using SI = Sales_item;
```

### 指针、常量、类型别名

存在const时，const**修饰的是类型别名这一完整的类型**，而非文字替换。

```cpp
typedef char* pstring;
const pstring cstr = 0;
```

## auto

局部变量的类型推导，不需要记忆规则，看IDE提示即可。

## decltype

计算表达式的类型，从而使用，不需要记忆规则，看IDE提示即可。
