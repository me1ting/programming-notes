# 基本概念

## 局部对象

大多数语言都区分`全局对象`和`局部对象`，但C还将局部对象区分为：

- 自动对象
- 局部静态对象，具备类似全局变量一样的生存期

这是C将`作用域`和`生存期`两个概念进行区分的结果，局部和全局是作用域的区分，自动和静态是生存期的区分。

> 以后的语言都对此进行了简化，因为`局部静态对象`的使用场景很小很小，将其从语法上删除，仅保留全局对象和局部对象的概念

## 函数声明与分离式编译

历史原因，虽然比较原始，但只有接受。

# 参数传递

## 引用传递与值传递

引用是C++的一个`特化语法`，从语法一致性来讲是不够协调的（对使用者来讲就是反自觉，需要额外的记忆成本）：

- 创建引用只取决于左值，如：`int &b = a;`
- 同理参数传递只取决于形式变量

某种程度来讲，可以理解为一种`隐式转换`。

> Rust对此进行了修正

## const形参和实参

这里我们探讨的是`顶层const`（也就是能否通过指针、引用来修改目标对象），从逻辑上来讲：

- const形参是对函数的限制，表示其无法修改目标对象
- const实参无法传递给非const形参数，因为函数可能通过指针或引用来修改目标对象

总之，这不违背逻辑，但是需要思考成本。

> Rust将不可变作为默认，避免这种费脑细胞的思维成本

## 数组形式参数

由于C的历史原因，C中数组基本等价于指向数组的指针。

由于这个原因，数组长度需要手动传递给函数，其“最佳实践”参考本书当前章节。

> 最佳实践本质是因为语言设计缺陷所导致的记忆负担

## main函数

//more

## 可变参数

//more

# 返回值

## 返回引用

由于C++在引用设计上的不合理，返回引用也是一种需要特别记忆的另类的语法：

```c++
const string &shorterString(){
    //more
}
```

同时由于左右值的区分，只有返回的引用是一个左值，可以作为左值使用：

```c++
get_val(s, 0) = 'A';
```

> 合法，但是需要记忆成本，而且与大多数语言相违和

## 列表初始化返回值

返回值可以是一个列表初始化，表示用其来初始化返回值类型，如一个vector。

## main函数的返回值

在大多数操作系统中，main函数的返回值表示状态。

## 返回数组指针

由于设计问题，数组只能以指针的方式返回，语法形式比较繁琐，让人难以理解。

## 尾置返回类型

C风格的函数声明面对复杂返回值类型时有些力不从心，让人难以使用和辨别，特别是返回复杂指针。

尾置返回类型吸收了Go,Rust等现代语言的函数声明，使得未来可期：

```c++
auto func(int i) -> int(*)[10];
```

> auto是为了兼容传统风格的占位符，风格确实有点不伦不类

## 使用decltype

`decltype`是编译时类型推断，使用场景很小。

# 重载

`函数重载`通过参数列表来区分功能，合情合理，但由于不恰当的使用，很多API用户难以辨别所需要使用的是哪个重载函数。

> 许多现代语言（Go,Rust）放弃了函数重载功能，用户通过函数名称来更清晰的实现这种需求，但这也有可能导致函数名膨胀

### const与重载

规则如下：

- 顶层常量无法用于区别参数列表
- 常量的指针/引用可以用来区别参数列表；对于非常量实参，如果同时存在常量和非常量参数版本的函数，默认调用非常量参数版本（可以使用`const_cast`将非常量强制转换为常量）

> 可以理解，但是存在思考/记忆负担

# 特殊用途feature

## 默认实参

//more

> JavaScript,Python都支持这种语法，但是存在细微区别：默认实参是否必须是`常量表达式`（按C++术语来说）？如果允许动态值，那该值是函数声明时计算，还是每次调用都动态计算？...
>
> 总之，一个看似花哨但没多大用的feature

## 内联函数

`请求`编译器将函数逻辑copy而非跳转，问题在于这取决于编译器。

> 不确定性的语法

## constexpr函数

该函数可以在常量表达式中使用。

## debug

//more

# 函数匹配

除了精确匹配外，`const`,`隐式类型转换`允许将看似不匹配的函数调用得以匹配，总之看似方便，实际则增加思维负担。

# 函数指针

//more
