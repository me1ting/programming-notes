# 基本概念

## 语法结构

类的基本结构如下：

```c++
struct Sales_data {
    //成员函数
    std::string isbn() const {/*more*/}
    //...
    //成员变量
    std::string bookNo;
    usigned int units_sold = 0;
    //...
};//末尾的分号是必须，在Rust中不需要
//非成员接口函数，即参数或返回值为该类型
Sales_data add(const Sales_data&,const Sales_data&);
```

### 成员函数

与函数一样，类同样包括`声明`和`定义`（主要是成员函数）两个部分，`成员函数`虽然可以在声明中定义（默认表示`inline`），但是考虑代码整洁性，还是分开为好。

### this常量指针

使用`this`表示调用方法的对象，它是一个常量指针

#### 返回this

一个返回this的函数，意味着返回的是调用对象的引用，那么其模板应当如下：

```c++
Type& Type::doSomething(){//返回类型是引用
    //more
    return *this;//想想赋值，引用没有取引用操作，返回对象值就是返回引用
}
```

### 后置const表示this的指向也是const

即无法使用`this`来修改调用方法的对象，这是因为：

**常量对象、常量对象的引用或指针只能调用常量方法**

由于this是隐藏的，需要某个语法来表示this是const对象的常量指针。

> 同C++的很多语法一样，逻辑上可以理解，但因为很绕导致严重的思考和记忆成本；
>
> 因此Rust的默认不可变，反过来就没有C++那么绕了。

### 非成员函数

非成员接口函数在Rust称为`关联函数`，在C++中也可以使用命名空间来实现类似的效果。

# 构造函数

`构造函数`是C++中类的一种特殊函数，用于定义对象的初始化过程。

> 由于其设计的复杂性，后面的Go,Rust都选择了取消这种语法。
>
> 相关链接https://www.zhihu.com/question/36586808（随便看看，因为看了也相当于白看）

## 初始化步骤

目前书中没有对此进行探讨，这里只是个人的猜测，简单分为两步：

- 先对成员变量进行初始化，优先级包括：初始值列表、类内初始值、默认初始化
- 再执行构造函数中的逻辑，可能会对成员变量的值进行覆盖

//more

## 默认构造函数

当没有手动为类创建构造函数时，编译器会创建一个`默认构造函数`，它对对类的数据成员进行初始化：

- 使用类声明中的初始值
- 否则默认初始化该成员

### 狭义默认函数与广义默认函数

事实上默认函数可以区分为狭义和广义：

- 狭义默认函数，编译器创建的默认构造函数。
- 广义默认构造函数，无参数的默认构造函数，可以是编译器创建的，也可以是用户自定义的

除非特制编译器创建的那个默认构造函数，`默认构造函数`都是指的是广义默认构造函数。

### 缺陷

存在3个缺陷：

- _只有未定义构造函数才会生成默认构造函数_
- 定义在块或者类成员的基本类型或复合类型被默认初始化时，其值是未定义的
- 类类型的类成员必须存在默认构造函数才能生存默认构造函数（编译器会提醒）

## 语法细节

### =default

`=default`用于但我们创建有自己的构造函数，但又希望存在默认构造函数并使用默认逻辑时：

```c++
struct Data{
    Data() = default;
}
```

### 构造函数初始值列表

C++认为需要为初始化特别定义一种语法：

```c++
Data(std::string &s):bookNo(s){
    //more
}
```

> 目前而言，这是C++独有的。从底层来讲，初始化比赋值的效率更高。

### 委托构造函数

构造函数调用其它构造函数在对OOP来说是常见功能，但是因为C++区分`初始化值列表`和构造函数逻辑两部分，因此需要**一种语法**而非在构造函数逻辑中直接调用其它构造函数。

### 转换构造函数

//more

# 拷贝、赋值、析构函数

目前需要知道的是，这三个功能由函数承载；与构造函数一样，如果没有手动定义这些函数，编译器会生成默认逻辑。

//more

# 控制与封装

## 访问说明符

C++使用`访问说明符`并使用独特的语法结构：

```c++
class Data{
    //默认范围权限
    public:
    //more
    private:
    //more
    protected:
    //more
}
```

通过访问说明符，将函数内的成员分为多个部分，每个部分具有不同的访问权限。

## struct与class

`class`使用C++相比C新增的关键字，功能基本相同，不同在于默认访问权限：

- struct的默认访问权限是public
- class的默认访问权限是private

## 友元

C++认为还需要一种语法来在前面的权限控制模型上开一个口子，满足一些特殊需求。

> 相比后续的OOP语言，这也是C++的一个特有功能，现在看来这是C++复杂性的一部分

//more

# 其他feature

## 成员feature

### 类型成员（看似没啥用）

未类型创建别名，以便于在类内部使用。

### 使用inline手动内联

在定义处实现的成员函数是默认内联，对于外部实现的成员函数可以使用`inline`实现手动内联。

### 可变成员（复杂化）

同友元类似，这又是C++的一个“后门”语法，允许const对象中的部分成员是可变的。

> 这带来了复杂性

## 返回\*this的成员函数

### 返回对象引用还是返回对象副本？

在前面我们知道`this`是一个const指针，指向调用对象，我们可以返回`*this`，但其含义取决于返回值类型：

- 目标对象类型，返回的是对象的值或称为副本
- 目标对象类型的引用，返回的是对象的引用

> C++就是如此设计引用的，虽然很别扭。

### 基于const的重载

在函数章节我们学习到**常量的指针/引用参数可以重载非常量参数版本函数**，this作为隐藏参数，同样可以实现类似的功能，只是语法上需要特别设计而已。

```c++
Data &show(){}
const Data &show()const{}//后置const表示对*this的限定
```

## 聚合类

类似Java中的JavaBean，是对C++中的某种`struct`类型的**术语**描述：只包含公开类成员变量的类。

# 类的作用域

由于个人认为与大多数语言一致，所以跳过阅读这部分。

//more

# 类的静态成员

基本上和Java相同（准确的说是Java继承了这一语法）。不同的语法细节在于：

- 静态成员在类外部进行定义时，不能重复使用`static`
- 静态成员变量的初始化只能在外部进行

//more
