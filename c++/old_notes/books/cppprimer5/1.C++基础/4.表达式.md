# 基本概念

## 左值和右值

C++对表达式在使用范围上进行了区分：

- `左值`：可以用在赋值语句的左侧，表示使用对象的身份（内存地址）

- `右值`：不能用在赋值语句的左侧，表示使用对象的值

左值可以当右值使用，表示使用其值，反之不然。

其它语言中并没有显式区分两者，而C++区分两者的用意在于：

//more

## 优先级、结合律、求值顺序

不同的语言对于符号的`优先级`是存在差异的，因此除了熟悉最基本的优先级（+-\*/），一律使用括号。

同其它语言一样，在同一语句的表达式中，不应该执行存在互相影响，执行因为顺序不同而结果不同的子操作，比如调用两个相互影响的函数。

# 算数运算符

## 取整与取余

除了Python，主流编程语言取整方向为向0取整。

## 存在负数的取余

存在定义：`(m/n)*n+m%n=m`，因此负数参与的取余自然就可以得出。不必记忆公式，需要时查阅参考资料。

# 赋值运算符

首先`赋值`不等于初始化，虽然它们都可以使用`=`，都可以使用`初始化列表`。

其次，对于类而言，赋值运算是可以重载的。

# sizeof运算符

`sizeof`是编译时计算类型字节大小，其返回值是常量表达式，因此对于容器类型来说，其返回值是不包含元素的固定大小。

# 类型转换

## 转换规则

类型之间的转换规则在大多数语言中都比较通用，如：

- 对数字而言，范围大的向范围小的使用截断转换，可能溢出；有符号数向无符号数转换沿用底层表示，可能数值失效；
- 对布尔而言，0、null转换为false，否则为0
- ...

## C风格隐式类型转换

这算是C的一大“陷阱”，不必去记忆规则，避免不同类型之间的隐式类型转换。

## 显式类型转换

## C风格显式类型转换

这种语法在类C语言中比较流行，但在C++已经被替代。

## C++风格显式类型转换

采用范型语法，存在几种不同的转换方式。

### static_cast

`static_cast` 表示常用类型转换，无特殊说明

### const_cast

对于const的指针，表示不允许使用该指针修改目标对象（指向的不一定就是const变量），是不可以将其赋值给普通指针的，因为后者语法上是可以修改目标对象的，因此赋值是不安全的。

使用`const_cast`类型转换可以实现这个目的，但是对于目标对象如果真是const，这种操作是不安全的。

### reinterpret_cast

顾名思义，重解释转换。其用于指针类型的转换，转换为指向不同的类型，如`char *`转换为`int *`。

其使用场景有限，而且很不安全。

### dynamic_cast

//more
