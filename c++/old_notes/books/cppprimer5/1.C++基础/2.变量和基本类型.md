# 前言

本章内容：C++的`变量`和`基本类型`的系统性知识。

# 基本类型

`基本类型`术语（个人认为）源自C，是对计算机底层数据类型的直接抽象。C++中分类为：

- 算术类型：整型（包括字符和布尔类型）、浮点型
- void类型

> 对比Rust，继承自C的字符和布尔类型更加接近底层，更加原始

整个知识体系基本与C语言相同。

## （糟糕的）字符类型与字符串类型

C++的字符类型与字符串类型是**原始的**，**臃肿的**，存在着大量糟糕的设计。

### 字符类型

C++中有多种字符类型`char`,`wchar_t`,`char16_t`,`char32_t`，但没一个是好用的。

简单对比Java,Go,Rust，它们都有**一个通用的字符类型**，可以实现：

- 接收字符常量，足够表示世界上现有的字符
- 参与到标准输出、字符串拼接、整个语言的标准库与第三方库

在C++中，我们可以使用`char32_t`配合`U`前缀来模拟这种需求，但仅能实现接收字符常量，其它语法、API环境都得不到支持。

```cpp
int main(){
    auto me = U'我';
    std::cout << me << std::endl;//无法以字符形式打印字符类型：25105
}
```

### 字符串类型

C++中的字符串也是一个充满补丁的缝合怪：

- C风格字符串常量，类型为字符类型数组，以'\0'结尾
- 鸡肋的`std::string`，基本等价于`vector<char>`
- `std::string_view`???
- `zstring`,`czstring`???(C++17)

简单对比Java,Go,Rust，它们都有**一个通用的字符串类型**（Rust有点例外，区分`&str`和`string`，但造成的困扰比C++小许多）：

- 使用一个通用的字符串编码方案，不一定等同于语言的字符类型采用的编码方案
- 接收字符串常量
- 参与到标准输出、字符串拼接、整个语言的标准库与第三方库

在C++中，我们可以：

- 在字符串常量上使用`u8`前缀来使用UTF-8编码方案
- //more

但多种字符串风格混搭产生的割裂感是必然存在的。

## （基本类型的）类型转换

## C风格的强制类型转换和自动类型转换

C++继承了C风格的类型转换，这带来的是复杂规则的记忆成本和由此产生的BUG。建议在C++中遗忘这种方式。

## C++风格类型转换

//more

# 变量

`变量`：一个具名的存储空间，其类型决定了变量所占空间的内存大小、布局方式、参与的运算、可以操作的语法……

`对象`：变量所对应的存储空间

`值`：对象所表示的信息

变量和对象是语言层面的抽象，可以理解为一种拥有或映射关系。

## 初始化

不同于其它语言，C++的`初始化`是一个重要概念，因为语言对其进行了深度解构，以便满足各种千奇百怪的需求。

`定义/声明`：创建变量，并确定其类型。

`初始化`：变量在创建时，如果得到一个特定的值，就称为对象被`初始化`了。

### 初始化不是赋值

在其它语言中，变量的初始化通常需要使用`=`来实现，这看起来就像`赋值`一样。但注意的是，C++中`初始化`与`赋值`需要区别对待，在后续章节会涉及：

- 章节3，直接初始化与拷贝初始化
- //more

### 列表初始化：一种统一的初始化语法

为了统一C++中的初始化而提供的一种语法，可以用于C++中的所有类型。形式是使用花括号括起来的初始值，可选的`=`：

```cpp;
int a = {0};//与传统形式统一，建议使用后者
int b{0};
```

### （糟糕的）默认初始化

`默认初始化`是C/C++令人诟病的一个设计，因为你需要记忆特别的规则，如果你忘记，那么编译器正常的代码可能在运行时出错。

规则：

- 内置基本类型的默认初始化值为0；但函数内的内置基本类型不被初始化，其值是未定义的。
- 类有决定是否默认初始、默认初始化值的权利。

建议：

- 内置基本类型总是显式初始化，这样我们规避掉了规则
- 类优先显式初始化，除非没有显式初始化的API

### （糟糕的）声明与定义

在一些语言中两者可以混为一谈，但C++中不然。由于继承了C的分离式编译，因此区分了两者：

- `声明`，使得名字为程序所知
- `定义`，负责创建与名字关联的实体

这种落后的设计，使得我们又不得不记忆许多额外的规则：

- 使用`extern`不包含初始值为声明
- 使用`extern`包含初始值为定义

# 复合类型

## 引用

`引用`实质是一种封装抽象后的指针，但比起指针而言，使用起来有种“黑魔法”的味道，语法设计得有些生硬，不够自然。

### （反直觉的）引用不是对象

C++将引用设计为一个特殊的存在，而不是普通的变量：

- 初始类似指针，但不需要取引用
- **不是对象，而是对象的别名**，无法修改引用目标
- 安全，不会出现空指针的情况

```cpp
int a = 1024;
int &refA = a;//类似指针的定义，但不需要取引用
```

> Rust将引用当作对象，体感与指针更为接近，但由于借用、移动等等设计，使用上也产生了许多怪异感。

## 指针

源自C，按C中的指针来理解即可。

### nullptr

强化语法，避免混用。

## （反直觉的）C++风格声明

C语法层面上并没有明确规定`指针类型`的概念，C++继承了这一点，也没有明确规定`引用类型`的概念。

因此会产生这样的代码：

```cpp
int a = 0;
int b = a, *c = &a, &d = a;//变量、指针变量、引用在同一行声明
```

虽然反直觉，但是类型不匹配在编译期就会被检查出来，除了增加记忆负担，问题倒还不大。

### 复杂的类型声明

在C时代，就存在多重指针、const等关键字导致难以理解的复杂声明；在C++时代，更容易写出难以理解的类型声明：

```cpp
int a = 0;
int *p = &a;
int *&r = p;//即使只包含指针和引用也难以让人理解
```

然后我们又不得不记忆反直觉的规则：

没有括号时，越靠近变量名，优先级越高：`&`修饰变量名，表示这是一个引用，引用目标是一个指针，其指向int类型。

# const

在C++中，`const`限定的变量是不可变得，个人称其为`运行时常量`。

## const与指针

在C时代就有const是修饰指针还是修饰指针所指向对象的区分，取决于前面所讲的`就近原则`。

## const与引用

引用本来就是不可变的，因此const只能修饰被引用对象。

## constexpr

`constexpr`用于修饰编译期就可以确定值的表达式、函数。

# 处理类型

## 类型别名

```cpp
using SI = Sales_item;
```

## decltype

//more
