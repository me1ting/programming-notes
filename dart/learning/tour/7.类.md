# 类
除了`null`所有值都是对象类型，且有一个基类`Object`。

（因为JavaScript的原因），dart选择`mixin-based`的类继承体系，细节有待进一步了解。

# 实例变量
```dart
class Point {
  double? x; // Declare instance variable x, initially null.
  double? y; // Declare y, initially null.
  double z = 0; // Declare z, initially 0.
}
```

正如在`变量.md`中所述，实例变量必须拥有初始值（默认值`null`也算），`late`是个例外。

非`late`实例变量的初始化，在构造器执行之前完成，此时无法访问`this`。

## getter&Setter
实例变量拥有[getter and setter](https://dart.dev/guides/language/language-tour#getters-and-setters)，是隐式生成的。

# 构造器
```dart
class Point {
  double x = 0;
  double y = 0;

  Point(double x, double y) {
    // See initializing formal parameters for a better way
    // to initialize instance variables.
    this.x = x;
    this.y = y;
  }
}
```
上述形式的构造器被称为`未命名构造器`，只能存在一个，也就是说，dart不支持java中那样的构造器重载。可以使用`命名构造器`来添加更多的构造器。

`this`是非强制的（不需要记忆，强制this的语言，编辑器会自动补充this）。

## 默认构造器
未命名、无参数的构造器，未提供构造器时，会默认创建无构造体的默认构造器。

与Java一样，默认构造器可以被覆盖，子类构造器会默认调用父类的默认构造器。

## 实例变量初始化
dart区分实例变量初始化和构造器逻辑，因此无法在构造体中初始化构造器。

我们可以在构造体中修改实例变量的值，这在其它语言中很常见，但是`final`修饰的实例变量，只能在初始化过程中赋值，也就是只能使用如下几种方式来实现调用构造器时初始化实例变量。

dart提供了一些语法来支持使用参数初始化实例变量，或使用常量等方式初始化实例变量。

### 初始化形式参数
`initializing formal parameters`语法，使得我们可以使用构造器的形式参数初始化实例变量。

```dart
class Point {
  final double x;
  final double y;

  // Sets the x and y instance variables
  // before the constructor body runs.
  Point(this.x, this.y);//使用;来表示空构造体的构造器
}


void main(){
  var a = Point(0,0);
}
```

### 初始化列表
[初始化列表](https://dart.dev/guides/language/language-tour#initializer-list)是初始化形式参数的另一种方式：
```dart
class Point {
  final double x;
  final double y;


  // Unnamed constructor
  Point(double i,double j)
      : x = i,//可以是形式参数、表达式、常量，不能调用this...
        y = j {
    print("created by unnamed constructor");
  }
}

void main() {
  var a = Point(1,2);
  print("${a.x} ${a.y}");
}
```

你甚至还可以在初始化列表中插入断言：
```dart
Point.withAssert(this.x, this.y) : assert(x >= 0) {
  print('In Point.withAssert(): ($x, $y)');
}
```

## 命名构造器
命名构造器提供了自定义名称的构造器，在其它语言中通常使用类静态方法模拟。

```dart
const double xOrigin = 0;
const double yOrigin = 0;

class Point {
  final double x;
  final double y;
  
  // Named constructor
  Point.origin()
      : x = xOrigin,
        y = yOrigin;//这里的;同样表示空构造体的构造器
}


void main(){
  var a = Point.origin();
}
```

## 调用父类构造器
默认情况，构造器会调用父类的默认构造器，其发生在初始化形式参数之后，执行构造体之前。

你可以显式调用父类的构造器：
```dart
  String? firstName;

  Person.fromJson(Map data) {
    print('in Person');
  }
}

class Employee extends Person {
  // Person does not have a default constructor;
  // you must call super.fromJson().
  Employee.fromJson(super.data) : super.fromJson() {//语法糖
    print('in Employee');
  }
}
```
上述代码中的语法糖是当子类和父类构造器形式参数一致时的简便写法，它的完整形式是：
```dart
class Employee extends Person {
  // Person does not have a default constructor;
  // you must call super.fromJson().
  Employee.fromJson(Map data) : super.fromJson(data) {//完整形式
    print('in Employee');
  }
}
```

对于初始化形式参数，也有类似的语法糖：
```dart
class Vector2d {
  final double x;
  final double y;

  Vector2d(this.x, this.y);
}

class Vector3d extends Vector2d {
  final double z;

  // Forward the x and y parameters to the default super constructor like:
  // Vector3d(final double x, final double y, this.z) : super(x, y);
  Vector3d(super.x, super.y, this.z);//语法糖
}
```

## 构造器重定向
在dart中，只能通过`构造器重定向`来让一个构造使用另一个构造器：
>这dart语法设计导致，更复杂的构造需求，只能通过工厂构造器来实现
```dart
class Point {
  double x, y;

  // The main constructor for this class.
  Point(this.x, this.y);

  // Delegates to the main constructor.
  Point.alongXAxis(double x) : this(x, 0);
}
```

## 常量构造器
```dart
class ImmutablePoint {
  static const ImmutablePoint origin = ImmutablePoint(0, 0);

  final double x, y;

  const ImmutablePoint(this.x, this.y);
}
```

只有在`常量上下文`(constant context)中创建的对象才是常量：
```dart
var a = const ImmutablePoint(1, 1);//常量
const b = ImmutablePoint(1, 1);//常量
var c = ImmutablePoint(1, 1);//非常量
```

## 工厂构造器
支持更灵活的构建对象。
```dart
class Logger {
  final String name;
  bool mute = false;

  // _cache is library-private, thanks to
  // the _ in front of its name.
  static final Map<String, Logger> _cache = <String, Logger>{};

  factory Logger(String name) {
    return _cache.putIfAbsent(name, () => Logger._internal(name));
  }

  factory Logger.fromJson(Map<String, Object> json) {
    return Logger(json['name'].toString());
  }

  Logger._internal(this.name);

  void log(String msg) {
    if (!mute) print(msg);
  }
}
```

`factory`关键字用在构造器上，表示该构造器是一个工厂构造器，因此该构造器不包含实例化阶段。

# 方法

## 符号重载
略

## Getter&Setter
实例变量会默认创建Getter和Setter（是否允许覆盖？），你可以也可以自定义：
```dart
class Rectangle {
  double left, top, width, height;

  Rectangle(this.left, this.top, this.width, this.height);

  // Define two calculated properties: right and bottom.
  double get right => left + width;
  set right(double value) => left = value - width;
  double get bottom => top + height;
  set bottom(double value) => top = value - height;
}
```

## 抽象函数
```dart
abstract class Doer {
  // Define instance variables and methods...

  void doSomething(); // Define an abstract method.
}

class EffectiveDoer extends Doer {
  void doSomething() {
    // Provide an implementation, so the method is not abstract here...
  }
}
```

# 抽象类
抽象类一般用来描述接口，只能用工厂构造器来提供抽象类的实例：
```dart
// This class is declared abstract and thus
// can't be instantiated.
abstract class AbstractContainer {
  // Define constructors, fields, methods...

  void updateChildren(); // Abstract method.
}
```

# 隐式接口
一个类型，它存在一个[隐式接口](https://dart.dev/guides/language/language-tour#implicit-interfaces)，包括：

- 所有实例变量（指getter和setter）
- 所有实例方法
- 它所实现的接口

其它类型，可以通过**实现该隐式接口**，来达成`as a`的效果：
```dart
// A person. The implicit interface contains greet().
class Person {
  // In the interface, but visible only in this library.
  final String _name;

  // Not in the interface, since this is a constructor.
  Person(this._name);

  // In the interface.
  String greet(String who) => 'Hello, $who. I am $_name.';
}

// An implementation of the Person interface.
class Impostor implements Person {
  String get _name => '';//因为目标是final，只需要定义getter

  String greet(String who) => 'Hi $who. Do you know who I am?';
}

String greetBob(Person person) => person.greet('Bob');
```

# 扩展类型
略

# 扩展方法
[扩展方法](https://dart.dev/guides/language/language-tour#extension-methods)可以通过库的形式，给类型添加新的方法。
```dart
import 'string_apis.dart';
...
print('42'.padLeft(5)); // Use a String method.
print('42'.parseInt()); // Use an extension method.
```

//TODO: 学习更多细节

# 枚举类型
略

# mixin类型
`mixin`是一类特殊的类型，只有实例字段和方法而没有构造器：
```dart
mixin Musical {
  bool canPlayPiano = false;
  bool canCompose = false;
  bool canConduct = false;

  void entertainMe() {
    if (canPlayPiano) {
      print('Playing piano');
    } else if (canConduct) {
      print('Waving hands');
    } else {
      print('Humming to self');
    }
  }
}
```
核心目的是复用代码，表现形式是给扩展类型时添加额外功能：
```dart
class Musician extends Performer with Musical {
  // ···
}
```

可以限制`mixin`的使用类型：
```dart
class Musician {
  // ...
}
mixin MusicalPerformer on Musician {//只有扩展Musician类型时才能使用该mixin
  // ...
}
class SingerDancer extends Musician with MusicalPerformer {
  // ...
}
```

## 类变量和类方法
略
