# 适配器

将一个类的接口转换成另一种接口，这两个接口不同，但功能应当是相同的。

目的是在不修改接口实现的情况下，完成代码的适配，常见于旧代码兼容；或未约定接口的情况下，分别开发功能最后合并。

# 装饰者

通过组合的方式，给类动态的增加功能，就像一层装饰一样。

装饰器实现功能的动态组合，适合需要在多个维度，灵活的对数据进行处理的场景。

>装饰器模式是很自然的被应用：我们需要对数据进行多个维度的处理，为了分离关注点、复用和可维护，每个维度的处理逻辑被抽象为一个方法或者一个接口的实现

典型示例如Java中的IO流，数据来源可能是文件、网络、内存，数据可能需要解密、解压、统计大小、计算摘要，这些操作的顺序需求可能各有不同，Java将这些功能都划分为独立的类来实现，只要按照需求进行搭配，就能得到想要的操作结果。

# 观察者

如何在单线程程序中，实现一对多的关联：当一做出变化时，多能够立即响应。

解决办法是一维护指向多的引用，并在发生变化时通知每一个多。

# 策略

将算法抽象为对象，使得算法可以作为组件独立的变化和组装使用。

# 外观

一个功能复杂的库通常分为多个组件，但对大多数用户来说过于繁琐，他们希望看下demo就能跑起来。

提供一个简单易用的顶层接口，大量采用默认设置，是设计库的一个好方法。

# 命令

两个类的依赖，通常是一个类的对象需要调用另一个类的对象的方法。但很多情况下，方法无法确定，依赖于外界，或者需要提供灵活性。此时可以将这种依赖抽象为对象，称为`命令`，对象之间的依赖通过命令对象解耦，更具有灵活性。

# 创建者

复杂对象的创建可能参数很多、情况复杂，可以将创建过程抽象一个对象，通过它来创建，甚至不同参数返回不同具体类型的对象。

# 工厂方法

原始定义：使用方法封装创建实例的过程，相比构造函数更具有灵活性。

个人理解：一些OOP语言定义了`构造器`这一语法来创建对象，但是**存在灵活性不足的问题**，所以允许`静态方法`来创建实例。

```java
static String valueOf(boolean b)
```

>Go,Rust直接取消了构造函数

# 抽象工厂

原始定义：使用一个工厂对象抽象创建一系列相关或相互依赖的接口的组合。

个人理解：一个包含了多个工厂方法、用来创建一系列相互关联/依赖的接口的实例的类型/接口。

# 原型模式
当复制对象比创建对象的成本更低时，使用原型模式。

说原型模式可能一头雾水，但`clone`大家都用过吧，其成为许多OOP语言的语法标配，就是原型模式的应用。

clone的设计可能很复杂，涉及深浅拷贝、线程安全等问题。

# 迭代器模式

对遍历聚合结构操作的封装。

其优点在于：

- 不暴露集合的内部实现
- 使用一个统一的接口（甚至语法）来遍历不同的聚合结构
- 允许实现不同的遍历方式，如树存在前序、中序、后序

存在`内部迭代器`和`外部迭代器`的区分，前者是`forEach()`，后者是`Iterator`。

# 责任链

当需要多个对象以先后顺序对请求进行处理时，使用责任链模式。

典型示例如Servlet Filter，SpringMVC Interceptor。

# 访问者

访问者模式是对OOP中访问类的内部属性的封装，使用方法来隔离内部实现。

如同clone,iterator，访问者模式也已经是大多数OOP语言的标配，甚至被集成到语言语法中，称这样的属性为property。

# 状态
对于由状态驱动的系统，一种直观的编程方式是建立一个系统类，定义枚举状态，定义接口方法。方法根据系统当前的状态，执行相应的逻辑。

这种方式的问题是当需要增加新的状态时，你需要修改所有的方法。将所有内容囊括在一个大类中，导致思维的混乱，代码会很难维护。

状态模式是将系统的状态封装，由它来控制系统的行为，这样在编程的重点放在实现一个个状态类，这样的拆分有利于维护和程序编写。

当需要变更逻辑时，只需要修改涉及的状态。当需要新增状态时，只需要添加一个状态。

# 模板方法
某些场景，处理的大致流程是固定的，细枝末节留给具体的实现类实现，适合使用模板方法。

模板方法是将算法在抽象类中进行固定，并将具体实现通过抽象方法独立出来，留给子类实现。

具体实现可以采用抽象方法或钩子方法，后者提供了默认实现，子类可以选择性覆盖。